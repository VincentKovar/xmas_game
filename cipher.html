<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tradecraft Cypher Decoder</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for the wheel elements */
        .ring {
            position: absolute;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.4); /* Green glow effect */
            user-select: none;
            touch-action: none; /* Crucial for preventing unwanted scrolling during drag */
        }
        .letter-fixed, .letter-rotatable {
            position: absolute;
            transform-origin: 0 0;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        /* Custom font for a spy look */
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap');
        body {
            font-family: 'Roboto Mono', monospace;
            background-color: #1a1a1a;
        }
        #keyDisplay {
            text-shadow: 0 0 5px #00ff00;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 text-white">

    <div class="w-full max-w-lg bg-gray-900 p-6 rounded-xl shadow-2xl border border-green-700">
        <h1 class="text-3xl font-bold text-center text-green-400 mb-6 border-b border-green-700 pb-2">
            Cypher Decoder 
        </h1>

        <!-- Key Display & Instructions -->
        <div class="text-center mb-8">
            <p class="text-sm uppercase text-gray-400">Current Decryption Key</p>
            <div id="keyDisplay" class="text-6xl text-green-500 font-extrabold">0</div>
        </div>

        <!-- Cipher Wheel Container -->
        <div id="wheelContainer" class="relative mx-auto" style="width: 300px; height: 300px;">

            <!-- Outer Fixed Ring (A-Z) -->
            <div id="outerRing" class="ring w-full h-full border-4 border-gray-700 bg-gray-800 text-green-300">
                <!-- Letters generated by JS -->
            </div>

            <!-- Inner Rotatable Ring (A-Z) -->
            <div id="innerRing" class="ring w-4/5 h-4/5 border-4 border-green-500 bg-gray-900 text-red-500 cursor-grab active:cursor-grabbing" style="transition: transform 0.05s linear;">
                <!-- Letters generated by JS -->
            </div>

            <!-- Red Target Marker -->
            <div class="absolute top-0 left-1/2 -ml-1 h-1/2 w-0.5 bg-red-600 pointer-events-none" style="transform-origin: bottom; transform: translate(-50%, 0);"></div>
            <div class="absolute top-0 left-1/2 -translate-x-1/2 -translate-y-1/2 w-4 h-4 rounded-full bg-red-600 z-20 pointer-events-none"></div>
        </div>

        <!-- Input / Output Section -->
        <div class="mt-12">
            <label for="cipherInput" class="block text-sm font-medium text-gray-400 mb-2">Message Intercept (Cipher):</label>
            <textarea id="cipherInput" rows="3" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:ring-green-500 focus:border-green-500 resize-none" placeholder="Enter one or more ciphertext letters here..."></textarea>
        </div>
        
        <div class="mt-4">
            <label for="plaintextOutput" class="block text-sm font-medium text-green-400 mb-2">Decoded Transmission (Plaintext):</label>
            <textarea id="plaintextOutput" rows="3" readonly class="w-full p-3 bg-gray-700 border border-green-500 rounded-lg text-white focus:outline-none resize-none"></textarea>
        </div>

    </div>

    <script>
        // DOM Elements
        const outerRing = document.getElementById('outerRing');
        const innerRing = document.getElementById('innerRing');
        const keyDisplay = document.getElementById('keyDisplay');
        const cipherInput = document.getElementById('cipherInput');
        const plaintextOutput = document.getElementById('plaintextOutput');
        
        // State variables for rotation
        let isDragging = false;
        let startAngle = 0;
        let startRotation = 0; // The current rotation of the inner ring
        let currentKey = 0;
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

        // --- CORE LOGIC FUNCTIONS ---

        /**
         * Calculates the angle of a pointer (mouse/touch) relative to the center of an element.
         * @param {number} clientX - X coordinate of the pointer.
         * @param {number} clientY - Y coordinate of the pointer.
         * @returns {number} Angle in degrees (0 to 360).
         */
        function getAngle(clientX, clientY) {
            const rect = innerRing.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const deltaX = clientX - centerX;
            const deltaY = clientY - centerY;

            let angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
            
            // Adjust to 0-360 range relative to the top (Y-axis up)
            angle = (angle + 90 + 360) % 360; 
            return angle;
        }

        /**
         * Decrypts the cipher text using the current key.
         */
        function decryptText() {
            const cipherText = cipherInput.value.toUpperCase();
            let decryptedText = '';

            for (let i = 0; i < cipherText.length; i++) {
                const char = cipherText[i];
                const charCode = char.charCodeAt(0);

                if (charCode >= 65 && charCode <= 90) { // A is 65 (char code for 'A'), Z is 90
                    
                    // --- MODIFIED LOGIC: ADDITIVE SHIFT ---
                    // Decrypt by adding the key, and wrapping around 'Z'
                    let decryptedCharCode = charCode + currentKey;

                    // Wrap around if it goes past 'Z' (90)
                    if (decryptedCharCode > 90) {
                        decryptedCharCode -= 26; 
                    }
                    decryptedText += String.fromCharCode(decryptedCharCode);
                } else {
                    // Keep non-alphabetic characters (spaces, punctuation) unchanged
                    decryptedText += char;
                }
            }
            plaintextOutput.value = decryptedText;
        }

        /**
         * Updates the rotation and the key display.
         * @param {number} newRotation - The new rotation angle in degrees.
         */
        function updateRotation(newRotation) {
            // Normalize rotation to 0-359 degrees
            let normalizedRotation = newRotation % 360;
            if (normalizedRotation < 0) {
                normalizedRotation += 360;
            }

            // Apply rotation transform
            innerRing.style.transform = `translate(-50%, -50%) rotate(${newRotation}deg)`;

            // Calculate the key (offset)
            // 360 degrees / 26 letters = ~13.846 degrees per letter.
            let degreesPerLetter = 360 / 26;
            let key = Math.round(normalizedRotation / degreesPerLetter);

            // The key represents the number of letters the wheel has moved from A-to-A alignment.
            currentKey = key;
            if (currentKey === 26) currentKey = 0; // Key 26 is the same as Key 0

            keyDisplay.textContent = currentKey;
            decryptText();
        }

        // --- EVENT HANDLERS ---

        function handleStart(clientX, clientY) {
            isDragging = true;
            // Get the angle where the drag started
            startAngle = getAngle(clientX, clientY); 
            // Save the current rotation value
            startRotation = parseFloat(innerRing.style.transform.match(/rotate\(([^)]+)/)?.[1]) || 0;
        }

        function handleMove(clientX, clientY) {
            if (!isDragging) return;

            const currentAngle = getAngle(clientX, clientY);
            
            // Calculate the change in angle
            let deltaAngle = currentAngle - startAngle;

            // Handle wrap-around (e.g., crossing from 359 to 0) for smooth dragging
            if (deltaAngle > 180) {
                deltaAngle -= 360;
            } else if (deltaAngle < -180) {
                deltaAngle += 360;
            }

            // Calculate the new total rotation
            const newRotation = startRotation + deltaAngle;
            updateRotation(newRotation);
        }

        function handleEnd() {
            if (isDragging) {
                isDragging = false;
                
                // Snap to the nearest letter position for stability
                const rotation = parseFloat(innerRing.style.transform.match(/rotate\(([^)]+)/)?.[1]) || 0;
                const degreesPerLetter = 360 / 26;
                const snappedRotation = Math.round(rotation / degreesPerLetter) * degreesPerLetter;
                
                // Smoothly transition the snap
                innerRing.style.transition = 'transform 0.1s ease-out';
                updateRotation(snappedRotation);
                
                // Restore the linear transition after the snap
                setTimeout(() => {
                    innerRing.style.transition = 'transform 0.05s linear';
                }, 100);
            }
        }

        // --- INITIALIZATION ---

        /**
         * Creates and positions the letters around the circumference of a ring.
         */
        function createLetters(ring, isRotatable) {
            const radius = ring.offsetWidth / 2;
            const letterClass = isRotatable ? 'letter-rotatable' : 'letter-fixed';
            const initialRotation = isRotatable ? 0 : 0; 

            for (let i = 0; i < 26; i++) {
                const angle = i * (360 / 26);
                const letter = alphabet[i];

                const letterElem = document.createElement('div');
                letterElem.textContent = letter;
                letterElem.className = `${letterClass} text-sm md:text-md`;
                
                // Calculate position using trigonometry
                const x = radius + radius * Math.sin(angle * Math.PI / 180);
                const y = radius - radius * Math.cos(angle * Math.PI / 180);

                // Position the element
                letterElem.style.left = `${x}px`;
                letterElem.style.top = `${y}px`;
                
                // Center the text on its point
                letterElem.style.transform = `translate(-50%, -50%) rotate(${angle + initialRotation}deg)`;
                
                ring.appendChild(letterElem);
            }
        }

        function setupListeners() {
            // 1. Decryption Trigger (Input changes)
            cipherInput.addEventListener('input', decryptText);

            // 2. Dragging/Rotation Listeners (Mobile & Desktop)
            
            // Mouse events (Desktop)
            innerRing.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
            window.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
            window.addEventListener('mouseup', handleEnd);

            // Touch events (Mobile)
            innerRing.addEventListener('touchstart', (e) => handleStart(e.touches[0].clientX, e.touches[0].clientY));
            window.addEventListener('touchmove', (e) => handleMove(e.touches[0].clientX, e.touches[0].clientY));
            window.addEventListener('touchend', handleEnd);

            // Set initial transform for the inner ring's position
            innerRing.style.left = '50%';
            innerRing.style.top = '50%';
            innerRing.style.transform = 'translate(-50%, -50%) rotate(0deg)';
        }

        // Run setup functions on load
        window.onload = () => {
            createLetters(outerRing, false); // Fixed ring
            createLetters(innerRing, true);  // Rotatable ring
            setupListeners();
            decryptText(); // Initial run
        };
    </script>

</body>
</html>
